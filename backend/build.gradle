import javax.xml.parsers.DocumentBuilderFactory

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.5'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'com.netflix.dgs.codegen' version '6.0.3'
    id 'org.graalvm.buildtools.native' version '0.9.28'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    set('springModulithVersion', "1.1.4")
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.security:spring-security-config'
    implementation 'org.springframework.security:spring-security-core'
    implementation 'org.springframework.security:spring-security-web'

    testImplementation 'org.springframework.security:spring-security-test'

    implementation 'org.springframework.modulith:spring-modulith-starter-core'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'

    developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    testImplementation 'org.springframework.modulith:spring-modulith-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    implementation 'jakarta.validation:jakarta.validation-api:3.0.2'
    implementation 'jakarta.servlet:jakarta.servlet-api:5.0.0'

//    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    implementation 'com.auth0:java-jwt:3.18.2'

    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'

    annotationProcessor 'org.projectlombok:lombok'

    compileOnly 'org.projectlombok:lombok'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.seleniumhq.selenium:selenium-java:4.20.0'
    testImplementation 'junit:junit:4.13.1'
    implementation 'org.springframework.boot:spring-boot-docker-compose'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.modulith:spring-modulith-bom:${springModulithVersion}"
    }
}

//tasks.named('test') {
//    useJUnitPlatform()
//}

generateJava {
    schemaPaths = ["${projectDir}/src/main/resources/graphql-client"]
    packageName = 'com.example.backendapplication.codegen'
    generateClient = true
}

//compile -- компиляция исходных кодов проекта.
tasks.register('compileProject', JavaCompile) {
    description = 'Компиляция исходных кодов проекта'
    dependsOn 'classes'
}

//build -- компиляция исходных кодов проекта и их упаковка в исполняемый jar-архив.
//Компиляцию исходных кодов реализовать посредством вызова цели compile.
tasks.register('buildProject', Jar) {
    description = 'Компиляция исходных кодов проекта и упаковка в jarник'
    dependsOn 'compileJava'
    archiveFileName = 'BackendApplication.jar'
    from sourceSets.main.output
    manifest {
        attributes(
                'Main-Class': 'ru.cosmosway.web04.BackendApplication'
        )
    }
}

//clean -- удаление скомпилированных классов проекта и всех временных файлов (если они есть).
tasks.register('cleanProject', Delete) {
    description = 'Удаление скомпилированных классов проекта и временных файлов'
    delete 'build'
}

//xml - валидация всех xml-файлов в проекте.
tasks.register('xmlProject') {
    description = 'Валидация всех XML-файлов в проекте'
    doLast {
        def xmlFiles = fileTree(dir: '.', include: '**/*.xml')
        xmlFiles.each { file ->
            try {
                def factory = DocumentBuilderFactory.newInstance()
                def builder = factory.newDocumentBuilder()
                builder.parse(file)
                println "XML-файл '${file}' валиден"
            } catch (Exception e) {
                println "XML-файл '${file}' невалиден: ${e.message}"
            }
        }
    }
}

//doc - добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта, а также генерация и добавление в архив javadoc по всем классам проекта.
tasks.register('docProject') {
    description = 'Добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта, а также генерация и добавление в архив javadoc по всем классам проекта'

    dependsOn 'javadoc'
    doLast {
        def files = fileTree(dir: '.', include: '**/*.*')
        def md5s = [:]
        def sha1s = [:]

        files.each { file ->
            def md5 = file.bytes.encodeHex().toString().digest('MD5')
            def sha1 = file.bytes.encodeHex().toString().digest('SHA-1')

            md5s[file.name] = md5
            sha1s[file.name] = sha1
        }

        def manifestFile = file('build/tmp/jar/MANIFEST.MF')
        if (!manifestFile.exists()) {
            manifestFile.parentFile.mkdirs()
            manifestFile.createNewFile()
        }

        manifestFile.withWriterAppend { writer ->
            md5s.each { name, hash ->
                writer.writeLine("MD5-${name}: ${hash}")
            }
            sha1s.each { name, hash ->
                writer.writeLine("SHA1-${name}: ${hash}")
            }
        }

        def jarFile = tasks.named('jar').get().archiveFile.get().asFile
        def javadocDir = tasks.named('javadoc').get().destinationDir
        ant.zip(update: true, destfile: jarFile) {
            fileset(dir: javadocDir)
        }
    }
}

//scp - перемещение собранного проекта по scp на выбранный сервер по завершению сборки.
//Предварительно необходимо выполнить сборку проекта (цель build)
//tasks.register('scpProject') {
//
//}
////native2ascii - преобразование native2ascii для копий файлов локализации (для тестирования сценария все строковые параметры необходимо вынести из классов в файлы локализации).
//tasks.register('native2asciiProject') {
//
//}
//music - воспроизведение музыки по завершению сборки (цель build).
tasks.register('musicProject') {
    description = 'Воспроизведение музыки по завершению сборки (цель build)'
    doLast {
        exec {
            commandLine 'afplay', 'music/meow.wav'
        }
    }
}

//
////report - в случае успешного прохождения тестов сохраняет отчет junit в формате xml, добавляет его в репозиторий svn и выполняет commit.
//task reportProject(){
//
//}
//
////alt - создаёт альтернативную версию программы с измененными именами переменных и классов (используя задание replace/replaceregexp в файлах параметров) и упаковывает её в jar-архив.
////Для создания jar-архива использует цель build.
//task altProject(){
//
//}
//
////team - осуществляет получение из git-репозитория 3 предыдущих ревизий, их сборку (по аналогии с основной) и упаковку получившихся jar-файлов в zip-архив.
////Сборку реализовать посредством вызова цели build.
////diff - осуществляет проверку состояния рабочей копии, и, если изменения не касаются классов, указанных в файле параметров выполняет commit в репозиторий git.
////history - если проект не удаётся скомпилировать (цель compile), загружается предыдущая версия из репозитория git.
////Операция повторяется до тех пор, пока проект не удастся собрать, либо не будет получена самая первая ревизия из репозитория.
////Если такая ревизия найдена, то формируется файл, содержащий результат операции diff для всех файлов, измёненных в ревизии, следующей непосредственно за последней работающей.
//
//
//
//
//
